# 服务器详情页数据集成指南

## 概述

服务器详情页需要三种类型的历史数据来绘制折线图。当前这些方法返回空数据，您需要根据实际情况接入真实数据源。

## 数据格式说明

所有三个数据方法都返回 `List<FlSpot>` 类型，其中：

- `FlSpot(x, y)` 是 fl_chart 库定义的数据点
- `x` 值：时间点（0-23，表示最近24小时的每个小时）
- `y` 值：对应的数值（根据图表类型不同）

## 三个数据方法详解

### 1. 玩家人数数据 (`_getPlayerCountData()`)

**位置**: `lib/pages/server_detail_page.dart` 第21行

**用途**: 显示服务器最近24小时的在线玩家数变化

**数据格式**:

```dart
List<FlSpot> _getPlayerCountData() {
  // x: 0-23（小时）
  // y: 玩家数量（整数或小数）
  // 示例: [FlSpot(0, 10), FlSpot(1, 15), FlSpot(2, 12), ...]
}
```

**实现建议**:

#### 方案1: 从服务器项目数据获取

如果您在 `widget.serverItem` 中存储了历史数据：

```dart
List<FlSpot> _getPlayerCountData() {
  final playerHistory = widget.serverItem['playerHistory'] as List?;
  if (playerHistory == null || playerHistory.isEmpty) return [];
  
  return playerHistory
      .asMap()
      .entries
      .map((entry) => FlSpot(
            entry.key.toDouble(),  // 索引作为小时
            entry.value.toDouble(), // 玩家数量
          ))
      .toList();
}
```

#### 方案2: 从数据库读取

```dart
List<FlSpot> _getPlayerCountData() {
  // 假设使用 Hive 数据库
  final box = Hive.box('serverHistoryBox');
  final serverKey = widget.serverItem['address'];
  final history = box.get('${serverKey}_players') as List?;
  
  if (history == null) return [];
  
  return history
      .asMap()
      .entries
      .map((entry) => FlSpot(entry.key.toDouble(), entry.value.toDouble()))
      .toList();
}
```

#### 方案3: 使用状态管理（如 Provider）

```dart
List<FlSpot> _getPlayerCountData() {
  final historyProvider = Provider.of<ServerHistoryProvider>(context);
  final data = historyProvider.getPlayerHistory(widget.serverItem['address']);
  return data;
}
```

---

### 2. 服务器占用数据 (`_getServerLoadData()`)

**位置**: `lib/pages/server_detail_page.dart` 第39行

**用途**: 显示服务器最近24小时的资源占用率（CPU、内存等）

**数据格式**:

```dart
List<FlSpot> _getServerLoadData() {
  // x: 0-23（小时）
  // y: 占用率百分比（0-100）
  // 示例: [FlSpot(0, 45.5), FlSpot(1, 52.3), FlSpot(2, 48.7), ...]
}
```

**实现建议**:

#### 监控服务器资源

如果您的 Minecraft 服务器提供了资源监控 API 或日志：

```dart
List<FlSpot> _getServerLoadData() {
  // 从配置文件或API获取
  final loadHistory = widget.serverItem['loadHistory'] as List?;
  if (loadHistory == null) return [];
  
  return loadHistory
      .asMap()
      .entries
      .map((entry) => FlSpot(
            entry.key.toDouble(),
            (entry.value as num).toDouble(), // 确保是百分比 0-100
          ))
      .toList();
}
```

#### 计算CPU/内存占用

```dart
List<FlSpot> _getServerLoadData() {
  // 可以综合计算CPU和内存占用
  // cpuUsage: 0-100, memoryUsage: 0-100
  // 综合占用 = (cpu + memory) / 2
  
  final cpuHistory = widget.serverItem['cpuHistory'] as List?;
  final memHistory = widget.serverItem['memoryHistory'] as List?;
  
  if (cpuHistory == null || memHistory == null) return [];
  
  return List.generate(cpuHistory.length, (index) {
    final avgLoad = (cpuHistory[index] + memHistory[index]) / 2;
    return FlSpot(index.toDouble(), avgLoad.toDouble());
  });
}
```

---

### 3. 延迟数据 (`_getLatencyData()`)

**位置**: `lib/pages/server_detail_page.dart` 第57行

**用途**: 显示连接到服务器的网络延迟（ping）

**数据格式**:

```dart
List<FlSpot> _getLatencyData() {
  // x: 0-23（小时）
  // y: 延迟时间（毫秒）
  // 示例: [FlSpot(0, 15), FlSpot(1, 18), FlSpot(2, 12), ...]
}
```

**实现建议**:

#### 从历史ping记录获取

```dart
List<FlSpot> _getLatencyData() {
  final latencyHistory = widget.serverItem['latencyHistory'] as List?;
  if (latencyHistory == null) return [];
  
  return latencyHistory
      .asMap()
      .entries
      .map((entry) => FlSpot(entry.key.toDouble(), entry.value.toDouble()))
      .toList();
}
```

#### 实时计算平均延迟

如果您有详细的ping记录（每小时多次测量）：

```dart
List<FlSpot> _getLatencyData() {
  final detailedPings = widget.serverItem['detailedPings'] as Map?;
  if (detailedPings == null) return [];
  
  return List.generate(24, (hour) {
    final hourlyPings = detailedPings[hour.toString()] as List?;
    if (hourlyPings == null || hourlyPings.isEmpty) {
      return FlSpot(hour.toDouble(), 0);
    }
    
    // 计算该小时的平均延迟
    final avgPing = hourlyPings.reduce((a, b) => a + b) / hourlyPings.length;
    return FlSpot(hour.toDouble(), avgPing.toDouble());
  });
}
```

---

## 数据收集建议

为了让这些图表有意义，您需要实现数据收集机制：

### 1. 定时任务收集数据

```dart
// 可以使用 Timer 定期收集数据
Timer.periodic(Duration(hours: 1), (timer) {
  // 每小时收集一次数据
  collectServerData();
});
```

### 2. 数据存储结构建议

在 Hive 或其他数据库中，建议的数据结构：

```dart
{
  'serverAddress': 'mc.example.com:25565',
  'playerHistory': [10, 15, 12, 20, ...], // 24个数据点
  'loadHistory': [45.5, 52.3, 48.7, ...],   // 24个数据点
  'latencyHistory': [15, 18, 12, ...],      // 24个数据点
  'lastUpdate': '2026-01-10T20:00:00',
}
```

### 3. 数据更新策略

#### 选项A: 滚动窗口（推荐）

每小时添加新数据，删除最旧的数据，始终保持24个数据点：

```dart
void addDataPoint(List history, double newValue) {
  if (history.length >= 24) {
    history.removeAt(0); // 删除最旧的
  }
  history.add(newValue); // 添加最新的
}
```

#### 选项B: 时间戳索引

使用时间戳作为键，查询时转换为0-23：

```dart
Map<DateTime, double> timestampedData = {
  DateTime(2026, 1, 10, 0): 10.0,
  DateTime(2026, 1, 10, 1): 15.0,
  // ...
};
```

---

## 快速开始示例

如果您想快速测试图表功能，可以临时使用以下代码：

```dart
// 临时测试数据
List<FlSpot> _getPlayerCountData() {
  // 模拟一天的数据：夜间人少，下午人多
  return [
    FlSpot(0, 5), FlSpot(1, 3), FlSpot(2, 2), FlSpot(3, 1),
    FlSpot(4, 2), FlSpot(5, 3), FlSpot(6, 8), FlSpot(7, 15),
    FlSpot(8, 20), FlSpot(9, 25), FlSpot(10, 30), FlSpot(11, 35),
    FlSpot(12, 42), FlSpot(13, 48), FlSpot(14, 55), FlSpot(15, 60),
    FlSpot(16, 65), FlSpot(17, 58), FlSpot(18, 50), FlSpot(19, 40),
    FlSpot(20, 32), FlSpot(21, 25), FlSpot(22, 18), FlSpot(23, 10),
  ];
}
```

---

## 注意事项

1. **空数据处理**: 当前代码返回空列表 `[]`，图表会显示空白。这是正常的，等待您接入数据后即可显示。

2. **数据点数量**: 建议保持24个数据点（每小时一个），以获得最佳显示效果。

3. **Y轴范围**:
   - 玩家数量：根据服务器容量设置 `maxY`（当前默认70）
   - 服务器占用：固定为100（百分比）
   - 延迟：根据网络情况设置 `maxY`（当前默认100ms）

4. **性能考虑**: 如果数据量很大，考虑在后台线程处理或使用 `FutureBuilder`。

---

## 相关文件

- 详情页面: `lib/pages/server_detail_page.dart`
- 数据模型: 您可能需要创建 `lib/data/server_history.dart`
- 数据收集: 您可能需要创建 `lib/services/data_collector.dart`

---

## 需要帮助？

如果在数据集成过程中遇到问题，检查以下几点：

1. 数据格式是否为 `List<FlSpot>`
2. x 值是否在 0-23 范围内
3. y 值是否为有效数字
4. 数据是否按时间顺序排列
